#!/usr/bin/env python3
"""
Archive.org Grateful Dead Query Engine
======================================

Query engine for Grateful Dead statistics using data from Archive.org.
Uses a pre-built local catalog (generated by archive_bootstrap.py) for fast queries.

Supports:
- Longest versions of songs (with actual jam durations!)
- Play counts and gaps
- First/last played dates
- Song statistics
- Show setlists
"""

import json
import re
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional, List, Dict, Any
from difflib import get_close_matches

# Path to the catalog file
CATALOG_PATH = Path(__file__).parent.parent / "data" / "grateful_dead_catalog.json"


@dataclass
class QueryResult:
    """Result from a query."""
    success: bool
    answer: str
    band: str = "Grateful Dead"
    highlight: str = ""
    card_data: Optional[Dict[str, Any]] = None
    related_queries: Optional[List[str]] = None


# Song aliases for the Grateful Dead
DEAD_SONG_ALIASES = {
    # Common abbreviations
    "dark star": "Dark Star",
    "pitb": "Playing in the Band",
    "playin": "Playing in the Band",
    "playing": "Playing in the Band",
    "nfa": "Not Fade Away",
    "gdtrfb": "Going Down the Road Feeling Bad",
    "goin down the road": "Going Down the Road Feeling Bad",
    "going down the road": "Going Down the Road Feeling Bad",
    "china cat": "China Cat Sunflower",
    "china": "China Cat Sunflower",
    "rider": "I Know You Rider",
    "i know you rider": "I Know You Rider",
    "ikyr": "I Know You Rider",
    "scarlet": "Scarlet Begonias",
    "fire": "Fire on the Mountain",
    "fotm": "Fire on the Mountain",
    "fire on the mountain": "Fire on the Mountain",
    "eyes": "Eyes of the World",
    "eotw": "Eyes of the World",
    "eyes of the world": "Eyes of the World",
    "estimated": "Estimated Prophet",
    "wharf rat": "Wharf Rat",
    "wrs": "Weather Report Suite",
    "weather report": "Weather Report Suite",
    "ujb": "Uncle John's Band",
    "uncle johns": "Uncle John's Band",
    "uncle john's band": "Uncle John's Band",
    "other one": "The Other One",
    "the other one": "The Other One",
    "too": "The Other One",
    "sugaree": "Sugaree",
    "sugar magnolia": "Sugar Magnolia",
    "sugarmag": "Sugar Magnolia",
    "morning dew": "Morning Dew",
    "dew": "Morning Dew",
    "st stephen": "St. Stephen",
    "saint stephen": "St. Stephen",
    "stephen": "St. Stephen",
    "truckin": "Truckin",
    "trucking": "Truckin",
    "bertha": "Bertha",
    "cassidy": "Cassidy",
    "casey jones": "Casey Jones",
    "casey": "Casey Jones",
    "terrapin": "Terrapin Station",
    "terrapin station": "Terrapin Station",
    "shakedown": "Shakedown Street",
    "shakedown street": "Shakedown Street",
    "deal": "Deal",
    "loser": "Loser",
    "brown eyed women": "Brown Eyed Women",
    "brown eyed": "Brown Eyed Women",
    "bew": "Brown Eyed Women",
    "bird song": "Bird Song",
    "birdsong": "Bird Song",
    "help on the way": "Help On The Way",
    "slipknot": "Slipknot!",
    "franklins tower": "Franklin's Tower",
    "franklin's tower": "Franklin's Tower",
    "franklins": "Franklin's Tower",
    "help slip frank": "Help On The Way",
    "hes gone": "He's Gone",
    "he's gone": "He's Gone",
    "jack straw": "Jack Straw",
    "althea": "Althea",
    "touch of grey": "Touch of Grey",
    "touch": "Touch of Grey",
    "box of rain": "Box of Rain",
    "box": "Box of Rain",
    "ripple": "Ripple",
    "brokedown palace": "Brokedown Palace",
    "brokedown": "Brokedown Palace",
    "black peter": "Black Peter",
    "new speedway boogie": "New Speedway Boogie",
    "speedway": "New Speedway Boogie",
    "friend of the devil": "Friend of the Devil",
    "fotd": "Friend of the Devil",
    "tennessee jed": "Tennessee Jed",
    "jed": "Tennessee Jed",
    "drums": "Drums",
    "space": "Space",
    "drums space": "Drums",
    "el paso": "El Paso",
    "me and my uncle": "Me and My Uncle",
    "mama tried": "Mama Tried",
    "mexicali blues": "Mexicali Blues",
    "one more saturday night": "One More Saturday Night",
    "omsn": "One More Saturday Night",
    "saturday night": "One More Saturday Night",
    "stella blue": "Stella Blue",
    "stella": "Stella Blue",
    "row jimmy": "Row Jimmy",
    "ship of fools": "Ship of Fools",
    "ship": "Ship of Fools",
    "crazy fingers": "Crazy Fingers",
    "music never stopped": "The Music Never Stopped",
    "tmns": "The Music Never Stopped",
    "the music never stopped": "The Music Never Stopped",
    "us blues": "U.S. Blues",
    "johnny b goode": "Johnny B. Goode",
    "johnny b": "Johnny B. Goode",
    "around and around": "Around and Around",
    "promised land": "The Promised Land",
    "promised": "The Promised Land",
}


class ArchiveDeadEngine:
    """Query engine for Grateful Dead data from Archive.org catalog."""

    def __init__(self):
        self.catalog = None
        self.songs = {}
        self.shows = []
        self._load_catalog()

    def _load_catalog(self):
        """Load the pre-built catalog."""
        if not CATALOG_PATH.exists():
            print(f"Warning: Catalog not found at {CATALOG_PATH}")
            print("Run archive_bootstrap.py to build the catalog first.")
            return

        try:
            with open(CATALOG_PATH) as f:
                self.catalog = json.load(f)
                self.songs = self.catalog.get('songs', {})
                self.shows = self.catalog.get('shows', [])
                print(f"  Loaded Dead catalog: {len(self.songs)} songs, {len(self.shows)} shows")
        except Exception as e:
            print(f"Error loading catalog: {e}")

    def _resolve_song(self, query_name: str) -> Optional[str]:
        """Resolve a song name from query to canonical name."""
        if not self.songs:
            return None

        query_lower = query_name.lower().strip()

        # Check aliases first
        if query_lower in DEAD_SONG_ALIASES:
            canonical = DEAD_SONG_ALIASES[query_lower]
            if canonical in self.songs:
                return canonical

        # Direct match
        for song in self.songs:
            if song.lower() == query_lower:
                return song

        # Partial match
        for song in self.songs:
            if query_lower in song.lower() or song.lower() in query_lower:
                return song

        # Fuzzy match
        matches = get_close_matches(query_lower, [s.lower() for s in self.songs], n=1, cutoff=0.7)
        if matches:
            for song in self.songs:
                if song.lower() == matches[0]:
                    return song

        return None

    def _format_duration(self, seconds: float) -> str:
        """Format seconds as MM:SS or H:MM:SS."""
        if seconds >= 3600:
            hours = int(seconds // 3600)
            mins = int((seconds % 3600) // 60)
            secs = int(seconds % 60)
            return f"{hours}:{mins:02d}:{secs:02d}"
        else:
            mins = int(seconds // 60)
            secs = int(seconds % 60)
            return f"{mins}:{secs:02d}"

    def query_longest(self, song_name: str, top_n: int = 1) -> QueryResult:
        """Find the longest version(s) of a song."""
        canonical = self._resolve_song(song_name)
        if not canonical:
            return QueryResult(
                success=False,
                answer=f"I couldn't find a song matching '{song_name}' in the Dead catalog.",
                related_queries=["Try: longest Dark Star", "longest Playing in the Band"]
            )

        song_data = self.songs.get(canonical, {})
        performances = song_data.get('performances', [])

        if not performances:
            return QueryResult(
                success=False,
                answer=f"No performance data found for {canonical}.",
            )

        # Sort by duration
        sorted_perfs = sorted(performances, key=lambda x: x['duration'], reverse=True)

        if top_n == 1:
            longest = sorted_perfs[0]
            duration = self._format_duration(longest['duration'])
            avg_dur = self._format_duration(song_data.get('avg_duration', 0))
            total_plays = song_data.get('total_plays', 0)

            # Calculate how much longer than average
            if song_data.get('avg_duration', 0) > 0:
                ratio = longest['duration'] / song_data['avg_duration']
                context = f"{ratio:.1f}x longer than average ({avg_dur})"
            else:
                context = ""

            return QueryResult(
                success=True,
                answer=f"The longest {canonical} was {duration}, played at {longest['venue']} on {longest['date']}. {context}",
                highlight=duration,
                card_data={
                    'type': 'longest',
                    'title': canonical,
                    'stat': duration,
                    'subtitle': f"{longest['date']} â€¢ {longest['venue']}",
                    'context': context,
                    'extra': {
                        'total_performances': total_plays,
                        'avg_duration': avg_dur
                    }
                },
                related_queries=[
                    f"top 10 longest {canonical}",
                    f"average {canonical} length",
                    f"how many times did they play {canonical}"
                ]
            )
        else:
            # Top N list
            lines = [f"**Top {top_n} Longest {canonical} Versions:**\n"]
            for i, perf in enumerate(sorted_perfs[:top_n], 1):
                duration = self._format_duration(perf['duration'])
                lines.append(f"{i}. {duration} - {perf['date']} @ {perf['venue']}")

            return QueryResult(
                success=True,
                answer="\n".join(lines),
                highlight=self._format_duration(sorted_perfs[0]['duration']),
                card_data={
                    'type': 'list',
                    'title': f"Longest {canonical} Versions",
                    'items': [
                        {'rank': i+1, 'value': self._format_duration(p['duration']),
                         'date': p['date'], 'venue': p['venue']}
                        for i, p in enumerate(sorted_perfs[:top_n])
                    ]
                },
                related_queries=[f"longest {canonical}", f"{canonical} stats"]
            )

    def query_play_count(self, song_name: str) -> QueryResult:
        """Get play count for a song."""
        canonical = self._resolve_song(song_name)
        if not canonical:
            return QueryResult(
                success=False,
                answer=f"I couldn't find a song matching '{song_name}' in the Dead catalog."
            )

        song_data = self.songs.get(canonical, {})
        count = song_data.get('total_plays', 0)

        return QueryResult(
            success=True,
            answer=f"The Grateful Dead played {canonical} {count} times.",
            highlight=str(count),
            card_data={
                'type': 'count',
                'title': canonical,
                'stat': count,
                'stat_label': 'times played'
            },
            related_queries=[
                f"longest {canonical}",
                f"when did they first play {canonical}",
                f"when did they last play {canonical}"
            ]
        )

    def query_song_stats(self, song_name: str) -> QueryResult:
        """Get comprehensive stats for a song."""
        canonical = self._resolve_song(song_name)
        if not canonical:
            return QueryResult(
                success=False,
                answer=f"I couldn't find a song matching '{song_name}' in the Dead catalog."
            )

        song_data = self.songs.get(canonical, {})
        total_plays = song_data.get('total_plays', 0)
        first = song_data.get('first_played', 'Unknown')
        last = song_data.get('last_played', 'Unknown')
        avg_dur = self._format_duration(song_data.get('avg_duration', 0))
        longest = song_data.get('longest', {})
        longest_dur = self._format_duration(longest.get('duration', 0)) if longest else 'N/A'
        longest_date = longest.get('date', 'N/A') if longest else 'N/A'

        # Calculate gap (days since last played, using 1995-07-09 as final show)
        try:
            last_date = datetime.strptime(last, '%Y-%m-%d')
            final_show = datetime(1995, 7, 9)
            gap = (final_show - last_date).days
        except:
            gap = None

        answer_lines = [
            f"**{canonical}** - Grateful Dead Stats\n",
            f"Times played: {total_plays}",
            f"First played: {first}",
            f"Last played: {last}" + (f" ({gap} days before final show)" if gap else ""),
            f"Average length: {avg_dur}",
            f"Longest version: {longest_dur} ({longest_date})"
        ]

        return QueryResult(
            success=True,
            answer="\n".join(answer_lines),
            highlight=str(total_plays),
            card_data={
                'type': 'stats',
                'title': canonical,
                'stat': total_plays,
                'stat_label': 'times played',
                'extra': {
                    'first_played': first,
                    'last_played': last,
                    'avg_duration': avg_dur,
                    'longest': f"{longest_dur} ({longest_date})"
                }
            },
            related_queries=[
                f"longest {canonical}",
                f"top 10 longest {canonical}"
            ]
        )

    def query_first_played(self, song_name: str) -> QueryResult:
        """Find when a song was first played."""
        canonical = self._resolve_song(song_name)
        if not canonical:
            return QueryResult(
                success=False,
                answer=f"I couldn't find a song matching '{song_name}' in the Dead catalog."
            )

        song_data = self.songs.get(canonical, {})
        first = song_data.get('first_played', None)

        if not first:
            return QueryResult(
                success=False,
                answer=f"No performance data found for {canonical}."
            )

        # Find the show details
        performances = song_data.get('performances', [])
        first_perf = next((p for p in performances if p['date'] == first), None)
        venue = first_perf.get('venue', 'Unknown venue') if first_perf else 'Unknown venue'

        return QueryResult(
            success=True,
            answer=f"The Grateful Dead first played {canonical} on {first} at {venue}.",
            highlight=first,
            card_data={
                'type': 'date',
                'title': f"First {canonical}",
                'stat': first,
                'subtitle': venue
            },
            related_queries=[
                f"when did they last play {canonical}",
                f"{canonical} stats"
            ]
        )

    def query_last_played(self, song_name: str) -> QueryResult:
        """Find when a song was last played."""
        canonical = self._resolve_song(song_name)
        if not canonical:
            return QueryResult(
                success=False,
                answer=f"I couldn't find a song matching '{song_name}' in the Dead catalog."
            )

        song_data = self.songs.get(canonical, {})
        last = song_data.get('last_played', None)

        if not last:
            return QueryResult(
                success=False,
                answer=f"No performance data found for {canonical}."
            )

        # Find the show details
        performances = song_data.get('performances', [])
        last_perf = next((p for p in performances if p['date'] == last), None)
        venue = last_perf.get('venue', 'Unknown venue') if last_perf else 'Unknown venue'

        return QueryResult(
            success=True,
            answer=f"The Grateful Dead last played {canonical} on {last} at {venue}.",
            highlight=last,
            card_data={
                'type': 'date',
                'title': f"Last {canonical}",
                'stat': last,
                'subtitle': venue
            },
            related_queries=[
                f"when did they first play {canonical}",
                f"{canonical} stats"
            ]
        )

    def query_show_count(self, year: int = None) -> QueryResult:
        """Get total show count, optionally filtered by year."""
        if year:
            shows = [s for s in self.shows if s['date'].startswith(str(year))]
            count = len(shows)
            return QueryResult(
                success=True,
                answer=f"The Grateful Dead played {count} shows in {year} (that we have recordings for).",
                highlight=str(count),
                card_data={
                    'type': 'count',
                    'title': f'Shows in {year}',
                    'stat': count,
                    'stat_label': 'shows'
                }
            )
        else:
            count = len(self.shows)
            years = set(s['date'][:4] for s in self.shows)
            year_range = f"{min(years)}-{max(years)}" if years else "N/A"

            return QueryResult(
                success=True,
                answer=f"The Archive.org catalog has {count} Grateful Dead shows with track data, spanning {year_range}.",
                highlight=str(count),
                card_data={
                    'type': 'count',
                    'title': 'Total Shows',
                    'stat': count,
                    'stat_label': 'shows',
                    'extra': {'years': year_range}
                }
            )

    def query_setlist(self, date: str) -> QueryResult:
        """Get setlist for a specific date."""
        # Normalize date format
        date = date.strip()

        show = next((s for s in self.shows if s['date'] == date), None)
        if not show:
            return QueryResult(
                success=False,
                answer=f"No show found for {date}.",
                related_queries=["Try format: YYYY-MM-DD (e.g., 1977-05-08)"]
            )

        tracks = show.get('tracks', [])
        venue = show.get('venue', 'Unknown')
        location = show.get('location', '')

        lines = [f"**{date}** - {venue}" + (f", {location}" if location else "") + "\n"]
        for t in tracks:
            lines.append(f"  {t['song']} ({t['duration_str']})")

        return QueryResult(
            success=True,
            answer="\n".join(lines),
            highlight=date,
            card_data={
                'type': 'setlist',
                'title': date,
                'subtitle': f"{venue}" + (f", {location}" if location else ""),
                'tracks': [{'song': t['song'], 'duration': t['duration_str']} for t in tracks]
            }
        )

    def query_longest_overall(self, limit: int = 5) -> QueryResult:
        """Get the longest performances of ANY song (overall longest jams)."""
        all_performances = []

        # Skip non-jam entries (interviews, announcements, full mixes, etc.)
        skip_songs = ['Drums', 'Space', 'Drums/Space', 'Full Mix', 'Pre Show Press Conference With Bill Graham',
                      'Stage Announcements', 'Tuning', 'Crowd', 'Interview', 'Tape 1', 'Tape 2']

        for song_name, song_data in self.songs.items():
            # Skip Drums/Space and non-music entries
            if song_name in skip_songs or 'press conference' in song_name.lower() or 'full mix' in song_name.lower():
                continue

            performances = song_data.get('performances', [])
            for perf in performances:
                all_performances.append({
                    'song': song_name,
                    'date': perf['date'],
                    'venue': perf.get('venue', 'Unknown'),
                    'duration': perf['duration']
                })

        if not all_performances:
            return QueryResult(
                success=False,
                answer="No duration data found in the Dead catalog."
            )

        # Sort by duration descending and take top N
        sorted_perfs = sorted(all_performances, key=lambda x: x['duration'], reverse=True)[:limit]

        # Format the result
        longest = sorted_perfs[0]
        duration_str = self._format_duration(longest['duration'])

        if limit == 1:
            lines = ["**Longest Grateful Dead Performance Ever**\n"]
        else:
            lines = [f"**Top {limit} Longest Grateful Dead Jams**\n"]

        for i, perf in enumerate(sorted_perfs, 1):
            dur_str = self._format_duration(perf['duration'])
            lines.append(f"{i}. **{perf['song']}** - {dur_str} ({perf['date']} at {perf['venue']})")

        return QueryResult(
            success=True,
            answer="\n".join(lines),
            highlight=duration_str,
            card_data={
                'type': 'longest_overall',
                'title': 'Longest Dead Jams',
                'stat': duration_str,
                'subtitle': f"{longest['song']} - {longest['date']}",
                'extra': {
                    'top_performances': [
                        {'song': p['song'], 'duration': self._format_duration(p['duration']),
                         'date': p['date'], 'venue': p['venue']}
                        for p in sorted_perfs[:5]
                    ]
                }
            },
            related_queries=[
                f"longest {sorted_perfs[0]['song']}",
                f"longest {sorted_perfs[1]['song']}" if len(sorted_perfs) > 1 else None,
                f"{sorted_perfs[0]['song']} stats"
            ]
        )

    def query(self, question: str) -> QueryResult:
        """Parse and route a natural language query."""
        if not self.catalog:
            return QueryResult(
                success=False,
                answer="The Grateful Dead catalog hasn't been built yet. Run archive_bootstrap.py first."
            )

        q = question.lower().strip()

        # Check for "longest ever" overall queries (no specific song)
        overall_patterns = [
            r"longest\s+ever\s+(\w+\s+)?(jams?|songs?|versions?|performances?)",
            r"longest\s+(\w+\s+)?(jams?|songs?|versions?|performances?)\s+ever",
            r"longest\s+(jams?|songs?|versions?|performances?)\s+of\s+all\s+time",
            r"longest\s+dead\s+(jams?|songs?)",
            r"longest\s+grateful\s+dead\s+(jams?|songs?)",
            r"longest\s+ever$",
        ]
        is_overall = any(re.search(pat, q) for pat in overall_patterns)

        if is_overall:
            # Determine limit: plural = 5, singular = 1
            if any(word in q for word in ["jams", "songs", "versions", "performances"]):
                limit = 5
            else:
                limit = 1
            return self.query_longest_overall(limit=limit)

        # Top N longest patterns (for specific song)
        top_n_match = re.search(r'top\s*(\d+)\s+longest\s+(.+)', q)
        if top_n_match:
            n = int(top_n_match.group(1))
            song = top_n_match.group(2).strip()
            return self.query_longest(song, top_n=min(n, 25))

        # Longest patterns (for specific song)
        longest_match = re.search(r'longest\s+(.+?)(?:\s+ever|\s+version|\s+jam)?$', q)
        if longest_match:
            song = longest_match.group(1).strip()
            return self.query_longest(song)

        # Play count patterns
        count_patterns = [
            r'how many times.*(?:play|played|perform)\w*\s+(.+)',
            r'how (?:often|much).*play\w*\s+(.+)',
            r'(.+?)\s+play\s*count',
            r'times played\s+(.+)',
        ]
        for pattern in count_patterns:
            match = re.search(pattern, q)
            if match:
                song = match.group(1).strip().rstrip('?')
                return self.query_play_count(song)

        # First played
        first_match = re.search(r'(?:when|what).*first.*(?:play|perform)\w*\s+(.+)', q)
        if first_match:
            song = first_match.group(1).strip().rstrip('?')
            return self.query_first_played(song)

        # Last played
        last_match = re.search(r'(?:when|what).*last.*(?:play|perform)\w*\s+(.+)', q)
        if last_match:
            song = last_match.group(1).strip().rstrip('?')
            return self.query_last_played(song)

        # Stats patterns
        stats_patterns = [
            r'(.+?)\s+stats',
            r'stats\s+(?:for\s+)?(.+)',
            r'tell me about\s+(.+)',
            r'info(?:rmation)?\s+(?:on|about)\s+(.+)',
        ]
        for pattern in stats_patterns:
            match = re.search(pattern, q)
            if match:
                song = match.group(1).strip()
                return self.query_song_stats(song)

        # Show count
        if 'how many shows' in q:
            year_match = re.search(r'in\s+(\d{4})', q)
            year = int(year_match.group(1)) if year_match else None
            return self.query_show_count(year)

        # Setlist
        date_match = re.search(r'setlist.*(\d{4}-\d{2}-\d{2})|(\d{4}-\d{2}-\d{2}).*setlist', q)
        if date_match:
            date = date_match.group(1) or date_match.group(2)
            return self.query_setlist(date)

        # If query contains a song name, return stats
        for song in self.songs:
            if song.lower() in q:
                return self.query_song_stats(song)

        # Check aliases
        for alias, canonical in DEAD_SONG_ALIASES.items():
            if alias in q:
                return self.query_song_stats(canonical)

        return QueryResult(
            success=False,
            answer="I'm not sure what you're asking. Try questions like:\n- 'longest Dark Star'\n- 'how many times did they play Eyes of the World'\n- 'Scarlet Begonias stats'",
            related_queries=[
                "longest Dark Star",
                "Playing in the Band stats",
                "how many times did they play China Cat Sunflower"
            ]
        )


# Export song aliases for the unified engine
def get_dead_song_aliases() -> Dict[str, str]:
    """Return all Dead song aliases for the unified engine."""
    return DEAD_SONG_ALIASES


if __name__ == '__main__':
    # Test the engine
    engine = ArchiveDeadEngine()

    print("\nTesting queries:")
    print("=" * 50)

    test_queries = [
        "longest dark star",
        "how many times did they play eyes of the world",
        "scarlet begonias stats",
        "top 5 longest playing in the band"
    ]

    for q in test_queries:
        print(f"\nQ: {q}")
        result = engine.query(q)
        print(f"A: {result.answer[:200]}..." if len(result.answer) > 200 else f"A: {result.answer}")
